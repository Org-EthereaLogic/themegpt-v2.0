diff --git a/src/Server.js b/src/Server.js
index 05c074d8f36f1e91b806bb746b204a1a09069a34..b8649d332ab6dbf7ec224b1f4a7fcdcd8294bc81 100644
--- a/src/Server.js
+++ b/src/Server.js
@@ -15,6 +15,7 @@ import type {HTTPServer, FormattedCodeFrame} from '@parcel/utils';
 import invariant from 'assert';
 import path from 'path';
 import url from 'url';
+import os from 'os';
 import {
   ansiHtml,
   createHTTPServer,
@@ -33,8 +34,37 @@ import {URL, URLSearchParams} from 'url';
 import launchEditor from 'launch-editor';
 import fresh from 'fresh';
 
-export function setHeaders(res: Response) {
-  res.setHeader('Access-Control-Allow-Origin', '*');
+let defaultAllowedHostsCache = null;
+export function getDefaultAllowedHosts(): string[] {
+  if (!defaultAllowedHostsCache) {
+    defaultAllowedHostsCache = ['localhost'];
+
+    let interfaces = os.networkInterfaces();
+    for (let name in interfaces) {
+      for (let addr of interfaces[name]) {
+        defaultAllowedHostsCache.push(
+          addr.family === 'IPv6' ? `[${addr.address}]` : addr.address,
+        );
+      }
+    }
+  }
+
+  return defaultAllowedHostsCache;
+}
+
+export function setHeaders(
+  origin: ?string,
+  allowedHostname: ?string,
+  res: Response,
+) {
+  res.setHeader('Cache-Control', 'max-age=0, must-revalidate');
+
+  // Only set CORS headers when the Origin header is valid.
+  if (!origin || !verifyOrigin(origin, allowedHostname)) {
+    return;
+  }
+
+  res.setHeader('Access-Control-Allow-Origin', origin);
   res.setHeader(
     'Access-Control-Allow-Methods',
     'GET, HEAD, PUT, PATCH, POST, DELETE',
@@ -43,7 +73,57 @@ export function setHeaders(res: Response) {
     'Access-Control-Allow-Headers',
     'Origin, X-Requested-With, Content-Type, Accept, Content-Type',
   );
-  res.setHeader('Cache-Control', 'max-age=0, must-revalidate');
+}
+
+export function verifyOrigin(
+  origin: string,
+  allowedHostname: ?string,
+): boolean {
+  try {
+    let url = new URL(origin);
+    if (
+      url.protocol === 'file:' ||
+      url.protocol === 'chrome-extension:' ||
+      url.protocol === 'moz-extension:'
+    ) {
+      return true;
+    }
+
+    return verifyHost(url.hostname, allowedHostname);
+  } catch {
+    return false;
+  }
+}
+
+export function verifyHost(
+  requestHost: string,
+  allowedHostname: ?string,
+): boolean {
+  if (!requestHost) {
+    return false;
+  }
+
+  // IPv6 address
+  if (requestHost[0] === '[') {
+    let index = requestHost.indexOf(']');
+    if (index < 0) {
+      return false;
+    }
+
+    requestHost = requestHost.slice(0, index + 1);
+  } else {
+    // Remove port
+    let index = requestHost.indexOf(':');
+    if (index >= 0) {
+      requestHost = requestHost.slice(0, index);
+    }
+  }
+
+  if (allowedHostname) {
+    return requestHost === allowedHostname;
+  }
+
+  return getDefaultAllowedHosts().includes(requestHost);
 }
 
 const SLASH_REGEX = /\//g;
@@ -489,7 +569,19 @@ export default class Server {
 
     const app = connect();
     app.use((req, res, next) => {
-      setHeaders(res);
+      if (!verifyHost(req.headers.host, this.options.host)) {
+        res.statusCode = 403;
+        res.end('Host not allowed.');
+        return;
+      }
+
+      setHeaders(req.headers.origin, this.options.host, res);
+      if (req.method === 'OPTIONS') {
+        res.statusCode = 200;
+        res.end();
+        return;
+      }
+
       next();
     });
     await this.applyProxyTable(app);
